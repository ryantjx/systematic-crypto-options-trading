"""
Base strategy class and framework.
"""

from abc import ABC, abstractmethod
import pandas as pd
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime


@dataclass
class Position:
    """Represents an options position."""
    symbol: str
    option_type: str  # "call" or "put"
    strike: float
    expiry: datetime
    quantity: float  # Positive for long, negative for short
    entry_price: float
    entry_time: datetime
    
    
@dataclass
class Signal:
    """Trading signal generated by strategy."""
    timestamp: datetime
    action: str  # "buy", "sell", "hold"
    symbol: str
    option_type: str
    strike: float
    expiry: datetime
    quantity: float
    confidence: float  # 0 to 1
    reason: str


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.
    
    All strategies should inherit from this class and implement
    the required methods.
    """
    
    def __init__(self, name: str):
        self.name = name
        self.positions: List[Position] = []
        self.signals_history: List[Signal] = []
        self.pnl_history: List[float] = []
        
    @abstractmethod
    def generate_signals(self, market_data: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals based on market data.
        
        Args:
            market_data: DataFrame with current market state
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def calculate_position_size(self, signal: Signal, portfolio_value: float) -> float:
        """
        Calculate position size for a given signal.
        
        Args:
            signal: Trading signal
            portfolio_value: Current portfolio value
            
        Returns:
            Position size (number of contracts)
        """
        pass
    
    def add_position(self, position: Position) -> None:
        """Add a new position to the portfolio."""
        self.positions.append(position)
    
    def close_position(self, position: Position, exit_price: float, exit_time: datetime) -> float:
        """
        Close a position and calculate PnL.
        
        Returns:
            Realized PnL
        """
        pnl = (exit_price - position.entry_price) * position.quantity
        self.pnl_history.append(pnl)
        self.positions.remove(position)
        return pnl
    
    def get_portfolio_delta(self) -> float:
        """Calculate total portfolio delta exposure."""
        # TODO: Implement delta calculation across all positions
        return 0.0
    
    def get_portfolio_vega(self) -> float:
        """Calculate total portfolio vega exposure."""
        # TODO: Implement vega calculation across all positions
        return 0.0
    
    def get_summary_stats(self) -> Dict:
        """Get strategy performance statistics."""
        if not self.pnl_history:
            return {}
        
        pnl_series = pd.Series(self.pnl_history)
        
        return {
            'total_pnl': pnl_series.sum(),
            'avg_pnl': pnl_series.mean(),
            'win_rate': (pnl_series > 0).sum() / len(pnl_series),
            'sharpe_ratio': pnl_series.mean() / pnl_series.std() if pnl_series.std() > 0 else 0,
            'max_drawdown': (pnl_series.cumsum() - pnl_series.cumsum().cummax()).min(),
            'num_trades': len(self.pnl_history)
        }
